id: prd008-stash-interface
title: Stash Interface
problem: |
  Crumbs are individual work items. Trails group them. But there is no mechanism for crumbs to share runtime state. When multiple agents coordinate on related tasks, they need shared resources (files, URLs, connections), artifacts (outputs from one crumb as inputs to another), context (decisions, configuration), and coordination primitives (locks, counters).

  Without shared state, agents must pass information through external channels or encode it in crumb properties, which conflates task attributes with coordination state. We need a dedicated entity for shared state that is scoped to a trail (or global), versioned, and auditable.

  This PRD defines the Stash entity: the struct fields, stash types, entity methods for value management and coordination, and how stashes interact with the Table interface.
goals:
- id: G1
  goal: Define the Stash struct with all required fields
- id: G2
  goal: Define stash types and their semantics
- id: G3
  goal: Define entity methods for value access (SetValue, GetValue)
- id: G4
  goal: Define entity methods for counter operations (Increment)
- id: G5
  goal: Define entity methods for lock operations (Acquire, Release)
- id: G6
  goal: Define history entry structure for backend tracking
- id: G7
  goal: Specify how stashes are created, stored, and queried via the Table interface
- id: G8
  goal: Document error conditions for entity operations
requirements:
- group: R1
  title: Stash Struct
  items:
  - id: R1.1
    requirement: The Stash struct must include the following fields
  - id: R1.2
    requirement: StashID must be a UUID v7 (time-ordered) generated by the backend
      when Table.Set is called with an empty StashID
  - id: R1.3
    requirement: Stash scope (trail or global) uses the links table with `scoped_to`
      link type (see R13). Global stashes have no `scoped_to` link
  - id: R1.4
    requirement: Name must be unique within scope. For trail-scoped stashes, name
      must be unique within that trail. For global stashes, name must be unique among
      global stashes. Table.Set must reject duplicate names with ErrDuplicateName
  - id: R1.5
    requirement: Name must be non-empty. Table.Set must reject empty names with ErrInvalidName
  - id: R1.6
    requirement: Version starts at 1 on creation and increments on every mutation.
      Version is never reset
  - id: R1.7
    requirement: Value is stored as a JSON blob. The structure depends on StashType
      (see R2)
- group: R2
  title: Stash Types
  items:
  - id: R2.1
    requirement: A stash must have exactly one of the following types
  - id: R2.2
    requirement: StashType is stored as a string for JSON compatibility
  - id: R2.3
    requirement: StashType must be one of the valid types in 2.1. Table.Set must reject
      unrecognized types with ErrInvalidStashType
  - id: R2.4
    requirement: Type-specific entity methods (R5, R6) validate that the stash has
      the correct type before operating
- group: R3
  title: Creating Stashes
  items:
  - id: R3.1
    requirement: To create a new stash, the caller constructs a Stash struct and passes
      it to Table.Set
  - id: R3.2
    requirement: When Table.Set is called with an empty ID, the backend must generate
      a UUID v7 for StashID, set Version to 1, set CreatedAt to now, validate Name
      is non-empty (ErrInvalidName if empty), validate Name is unique in scope (ErrDuplicateName
      if exists), validate StashType is recognized (ErrInvalidStashType if not), and
      record a history entry with operation "create"
  - id: R3.3
    requirement: 'For lock type, initial Value should be nil (unlocked). For counter
      type, initial Value should be `{"value": 0}` or a specified starting value'
  - id: R3.4
    requirement: After successful creation, the Stash struct is updated with the generated
      StashID, Version, and CreatedAt
- group: R4
  title: Value Methods
  items:
  - id: R4.1
    requirement: The Stash struct provides methods for value access
  - id: R4.2
    requirement: SetValue updates the stash value. Must increment Version. Must return
      ErrInvalidStashType if called on a lock-type stash (use Acquire/Release instead).
      After calling SetValue, the caller must save with Table.Set to persist changes
  - id: R4.4
    requirement: Example usage
- group: R5
  title: Counter Operations
  items:
  - id: R5.1
    requirement: The Stash struct provides a method for counter operations
  - id: R5.2
    requirement: Increment atomically adds delta to the counter value. Must validate
      that StashType is "counter" (return ErrInvalidStashType if not). Must extract
      current value from Value field, add delta, and store result. Must increment
      Version. Must return the new counter value. Delta may be negative (decrement).
      After calling Increment, the caller must save with Table.Set to persist changes
  - id: R5.3
    requirement: Example usage
- group: R6
  title: Lock Operations
  items:
  - id: R6.1
    requirement: The Stash struct provides methods for lock operations
  - id: R6.2
    requirement: 'Acquire obtains the lock. Must validate that StashType is "lock"
      (return ErrInvalidStashType if not). Must validate that holder is non-empty
      (return ErrInvalidHolder if empty). If the lock is not held (Value is nil),
      set Value to `{"holder": holder, "acquired_at": now}`. If the lock is already
      held by the same holder, succeed (reentrant). If the lock is held by another
      holder, return ErrLockHeld. Must increment Version. After calling Acquire, the
      caller must save with Table.Set to persist changes'
  - id: R6.3
    requirement: Release releases the lock. Must validate that StashType is "lock"
      (return ErrInvalidStashType if not). Must validate that the lock is held by
      the specified holder (return ErrNotLockHolder if not). Must set Value to nil
      (unlocked). Must increment Version. After calling Release, the caller must save
      with Table.Set to persist changes
  - id: R6.4
    requirement: Example usage
  - id: R6.5
    requirement: Lock operations are non-blocking. For waiting behavior, callers implement
      retry loops with backoff
- group: R7
  title: History Tracking
  items:
  - id: R7.1
    requirement: The backend maintains a history log of stash mutations. History is
      backend-managed, not accessed through entity methods
  - id: R7.2
    requirement: StashHistoryEntry contains the following fields
  - id: R7.3
    requirement: Operation constants (defined in pkg/types/stash.go)
  - id: R7.5
    requirement: The StashHistoryEntry struct is defined in pkg/types for backends
      to use when returning history data
  - id: R7.6
    requirement: Backend must provide a method to query stash history entries by stash
      ID, returning entries ordered by version ascending
- group: R8
  title: Retrieving Stashes
  items:
  - id: R8.1
    requirement: To retrieve a stash by ID, use Table.Get
  - id: R8.2
    requirement: Table.Get returns the entity as any; the caller must type-assert
      to *Stash
  - id: R8.3
    requirement: Table.Get returns ErrNotFound if no stash exists with the given ID
  - id: R8.4
    requirement: Table.Get returns ErrInvalidID if id is empty
- group: R9
  title: Filter Map
  items:
  - id: R9.1
    requirement: Filters are expressed as map[string]any where keys are filter names
      and values are filter criteria
  - id: R9.2
    requirement: Supported filter keys for stashes
  - id: R9.2.1
    requirement: To filter by trail scope, applications query the links table for
      `scoped_to` links and use the resulting stash IDs
  - id: R9.3
    requirement: An empty or nil filter matches all stashes
  - id: R9.5
    requirement: Unknown filter keys must be ignored (forward compatibility)
  - id: R9.6
    requirement: Results are ordered by CreatedAt ascending (oldest first)
- group: R10
  title: Querying Stashes
  items:
  - id: R10.1
    requirement: To query stashes by type, use Table.Fetch with a filter map
  - id: R10.2
    requirement: Table.Fetch returns a slice of entities ([]any); the caller must
      type-assert each element to *Stash
  - id: R10.3
    requirement: Table.Fetch returns an empty slice (not nil) if no stashes match
- group: R11
  title: Deleting Stashes
  items:
  - id: R11.1
    requirement: To delete a stash, use Table.Delete
  - id: R11.2
    requirement: Table.Delete removes the stash record and all its history
  - id: R11.3
    requirement: Table.Delete returns ErrNotFound if no stash exists with the given
      ID
  - id: R11.4
    requirement: Table.Delete returns ErrInvalidID if id is empty
  - id: R11.5
    requirement: Table.Delete returns ErrLockHeld if the stash is a lock and is currently
      held
- group: R12
  title: Error Types
  items:
  - id: R12.1
    requirement: Stash entity methods and Table operations use sentinel errors defined
      in pkg/types/table.go
  - id: R12.2
    requirement: All errors are checkable with errors.Is
  - id: R12.3
    requirement: Backend implementations may return additional errors for validation
      (e.g., duplicate names) as needed
- group: R13
  title: Stash Scoping
  items:
  - id: R13.1
    requirement: A stash can be scoped to a trail via a `scoped_to` link in the links
      table
  - id: R13.2
    requirement: A stash can have at most one `scoped_to` link. The backend must enforce
      this constraint
  - id: R13.3
    requirement: Stashes without a `scoped_to` link are global (accessible from any
      trail)
  - id: R13.4
    requirement: Stash scoping is managed via the links table. Applications create
      `scoped_to` links using the Table interface for the links table
  - id: R13.5
    requirement: To find which trail a stash is scoped to, query the links table for
      a `scoped_to` link where `from_id` equals the stash ID
  - id: R13.6
    requirement: To find all stashes scoped to a trail, query the links table for
      `scoped_to` links where `to_id` equals the trail ID
non_goals:
- This PRD does not define queue or channel stash types. These may be added in a future
  version
- This PRD does not define stash replication or cross-cupboard sharing
- This PRD does not define TTL or automatic expiration for stashes
- This PRD does not define access control or permissions on stashes
- This PRD does not define history compaction or pruning. History grows unbounded
- This PRD does not define blocking lock acquisition with timeout. Callers implement
  retry loops
acceptance_criteria:
- id: AC1
  criterion: Stash struct defined with StashID, Name, StashType, Value, Version, CreatedAt
    fields
- id: AC2
  criterion: Stash types documented (resource, artifact, context, counter, lock)
- id: AC3
  criterion: Entity methods defined for value access (SetValue, GetValue)
- id: AC4
  criterion: Entity methods defined for counter operations (Increment)
- id: AC5
  criterion: Entity methods defined for lock operations (Acquire, Release)
- id: AC6
  criterion: StashHistoryEntry struct documented for backend history tracking
- id: AC7
  criterion: History operation constants documented (create, set, increment, acquire,
    release)
- id: AC8
  criterion: Stash creation via Table.Set specified (ID generation, version initialization)
- id: AC9
  criterion: Stash retrieval via Table.Get specified (type assertion to *Stash)
- id: AC10
  criterion: Filter map defined with stash_type, name, limit, offset
- id: AC11
  criterion: Query via Table.Fetch specified (filter map, type assertion)
- id: AC12
  criterion: Stash deletion via Table.Delete specified (cascade to history)
- id: AC13
  criterion: Stash scoping semantics documented (scoped_to link, one per stash)
- id: AC14
  criterion: Error types documented
- id: AC15
  criterion: All requirements numbered and specific

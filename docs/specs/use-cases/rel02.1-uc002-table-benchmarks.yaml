id: rel02.1-uc002-table-benchmarks
title: Table Benchmarks
summary: 'A developer runs Go benchmarks against the crumbs Table interface with

  varying data sizes and measures operation latency. The benchmarks establish

  baseline performance numbers that future releases must not regress.

  '
actor: Developer or CI pipeline validating performance
trigger: Code change that could affect Table operation latency, such as modifying
  the SQLite backend, changing entity hydration, or altering JSONL persistence
flow:
- id: F1
  step: 'Create benchmark test files: add crumbs_bench_test.go in internal/sqlite
    package'
- id: F2
  step: 'Implement Get benchmarks at different scales: BenchmarkCrumbsGet10, Get100,
    Get1000, Get10000'
- id: F3
  step: 'Implement Set benchmarks for create: BenchmarkCrumbsSetCreate10, SetCreate1000'
- id: F4
  step: 'Implement Set benchmarks for update: BenchmarkCrumbsSetUpdate10, SetUpdate1000'
- id: F5
  step: 'Implement Delete benchmarks: BenchmarkCrumbsDelete10, Delete1000'
- id: F6
  step: 'Implement Fetch benchmarks with filters: FetchAll, FetchState, FetchProperties,
    FetchLimit'
- id: F7
  step: 'Implement property operation benchmarks: BenchmarkCrumbSetProperty, GetProperty
    at 10 and 1000 scale'
- id: F8
  step: 'Run benchmarks and capture baseline: go test -bench=. -benchmem ./internal/sqlite/...'
- id: F9
  step: 'Compare against baseline on code changes: use benchstat for statistical comparison'
touchpoints:
- T1: 'Table interface: Get, Set, Delete, Fetch (prd001-cupboard-core R3)'
- T2: 'SQLite backend: entity hydration from rows (prd002-sqlite-backend R14)'
- T3: 'SQLite backend: entity persistence to rows (prd002-sqlite-backend R15)'
- T4: 'SQLite backend: JSONL atomic write (prd002-sqlite-backend R5.2)'
- T5: 'SQLite backend: immediate sync strategy (prd002-sqlite-backend R16.2)'
- T6: 'Crumb entity: SetProperty, GetProperty (prd003-crumbs-interface R5)'
- T7: 'Crumb table: filter map queries (prd003-crumbs-interface R9)'
- T8: 'SQLite backend: idx_crumbs_state index (prd002-sqlite-backend R3.3)'
success_criteria:
- id: S1
  criterion: go test -bench=BenchmarkCrumbsGet -benchmem ./internal/sqlite/... runs
    without error
- id: S2
  criterion: go test -bench=BenchmarkCrumbsSet -benchmem ./internal/sqlite/... completes
    for create and update benchmarks
- id: S3
  criterion: go test -bench=BenchmarkCrumbsFetch -benchmem ./internal/sqlite/... completes
    for all filter types
- id: S4
  criterion: go test -bench=. -benchmem ./internal/sqlite/... > baseline.txt captures
    full benchmark suite to file
- id: S5
  criterion: baseline.txt contains all benchmarks reporting ns/op, B/op, allocs/op
- id: S6
  criterion: All benchmark functions execute without error
- id: S7
  criterion: Each benchmark reports consistent ns/op across multiple runs (variance
    under 10%)
- id: S8
  criterion: Memory allocations (B/op, allocs/op) are captured for regression tracking
- id: S9
  criterion: Baseline file is committed to the repository for future comparison
out_of_scope:
- Concurrent access benchmarks (prd002-sqlite-backend R8 describes single-writer model)
- Network latency (SQLite backend is local; no network overhead)
- CLI command overhead (benchmarks measure Table interface, not CLI parsing)
- Non-immediate sync strategies (prd002-sqlite-backend R16.3, R16.4 are deferred performance
  options)
- Trail and stash operations (those entity types are in later releases)
test_suite: test-rel02.1

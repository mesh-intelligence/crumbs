id: rel02.0-uc002-regeneration-compatibility
title: Regeneration Compatibility
summary: |
  The --regenerate cycle deletes all Go code, rebuilds cupboard from documentation,
  and verifies that the new generation reads and operates on JSONL data created by
  the previous generation. This validates backward compatibility across regeneration cycles.
actor: The do-work.sh --regenerate script
trigger: Developer or CI pipeline running a regeneration cycle to validate that cupboard can be rebuilt from documentation alone and remain compatible with existing data
flow:
  - id: F1
    step: "Build and install generation N: Generation N is built, tested, and installed. The go install step places the cupboard binary in $GOBIN. This binary becomes the reference implementation for the current JSONL format."
  - id: F2
    step: "Create JSONL data using generation N: Create crumbs using the generation N binary. This data represents the contract that generation N+1 must honor."
  - id: F3
    step: "Run --regenerate: The script tags the current repo state, deletes all Go source files, reinitializes the Go module, and commits. Internally runs git tag, find -delete, rm, go mod init, git add, git commit."
  - id: F4
    step: "Rebuild from documentation: The make-work/do-work loop rebuilds cupboard from documentation. The new code (generation N+1) is written by agents reading PRDs, architecture docs, and use cases. The agents produce a fresh implementation that must conform to the documented JSONL format (prd002-sqlite-backend R2)."
  - id: F5
    step: "Build generation N+1: Build and verify generation N+1 compiles successfully."
  - id: F6
    step: "Load generation N data with generation N+1: Point generation N+1 at the JSONL data created by generation N. The backend's startup sequence (prd002-sqlite-backend R4) loads JSONL into SQLite. If the format has drifted, this step fails."
  - id: F7
    step: "Verify read operations: Verify read operations against generation N data return correct values."
  - id: F8
    step: "Verify write operations: Verify write operations update generation N data correctly. Generation N+1 must write JSONL in a format that both itself and generation N can read."
  - id: F9
    step: "Verify generation N reads N+1 modifications: Verify the installed generation N binary can still read the data after generation N+1 modifies it. This confirms write compatibility in both directions."
  - id: F10
    step: "Verify property operations across generations: If generation N defined properties and set values, generation N+1 must load those properties and values correctly (requires rel02.0 property enforcement)."
touchpoints:
  - T1: "mage openGeneration / closeGeneration: Orchestrates the regeneration cycle (tag, delete, reinit, rebuild)"
  - T2: "SQLite backend startup: Loads JSONL files into SQLite; format must match across generations (prd002-sqlite-backend R4)"
  - T3: "JSONL file format: The contract between generations; format stability is the invariant (prd002-sqlite-backend R2)"
  - T4: "JSONL write path: Writes must produce JSONL that older and newer generations can parse (prd002-sqlite-backend R5)"
  - T5: "Unknown field handling: Unknown fields in JSONL are ignored, enabling forward compatibility (prd002-sqlite-backend R7.2)"
  - T6: "Cupboard interface: Attach/Detach, GetTable work identically across generations (prd001-cupboard-core R4, R5)"
  - T7: "Property system: Property definitions and values persist across regeneration (prd004-properties-interface R4)"
success_criteria:
  - id: S1
    criterion: Build and install generation N succeeds, cupboard --help works from $GOBIN
  - id: S2
    criterion: Create crumbs with generation N produces crumbs.jsonl with the created entries
  - id: S3
    criterion: Run --regenerate deletes Go files, reinitializes module, creates clean commit, and creates tag
  - id: S4
    criterion: Build generation N+1 from fresh code succeeds, new binary produced
  - id: S5
    criterion: Generation N+1 reads generation N data via list crumbs, returning all crumbs created in step 2
  - id: S6
    criterion: Generation N+1 modifies generation N data via set crumbs, JSONL reflects change
  - id: S7
    criterion: Generation N (installed cupboard) reads data modified by N+1 and returns updated values
  - id: S8
    criterion: Properties and values created by N are readable by N+1
out_of_scope:
  - Schema migrations or versioned JSONL formats (we rely on format stability and unknown-field tolerance)
  - Testing more than two generations in sequence (N and N+1 only)
  - Cross-platform compatibility (both generations run on the same OS/architecture)
  - Performance comparison between generations
  - Validating that agents produce correct code during regeneration (that is the make-work/do-work loop's responsibility)
test_suite: test-rel02.0

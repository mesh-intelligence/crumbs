id: test-rel03.0
title: Trails and Stashes
release: '03.0'
traces:
- rel03.0-uc001-trail-exploration
- rel03.0-uc002-link-management
- rel03.0-uc003-stash-operations
- rel03.0-uc004-trail-crumb-lifecycle
preconditions:
- Cupboard initialized with SQLite backend
- trails, crumbs, and links tables accessible via GetTable
- No existing trails, crumbs, or links in the database
- links, crumbs, trails, and stashes tables accessible via GetTable
- No existing links in the database
- stashes table accessible via GetTable
- No existing stashes in the database
test_cases:
- name: Create trail defaults to draft state
  description: When no state is provided, new trails default to draft state per prd006-trails-interface R2.2
  inputs:
    args:
    - 'trail := &Trail{CreatedAt: time.Now()} trailsTable.Set("", trail) '
  expected:
    exit_code: 0
- name: Create trail with explicit active state
  inputs:
    args:
    - 'trail := &Trail{State: "active", CreatedAt: time.Now()} trailsTable.Set("", trail) '
  expected:
    exit_code: 0
- name: Create trail in draft state explicitly
  inputs:
    args:
    - 'trail := &Trail{State: "draft", CreatedAt: time.Now()} trailsTable.Set("", trail) '
  expected:
    exit_code: 0
- name: Transition trail from draft to active via SetState
  inputs: {}
  expected:
    exit_code: 0
- name: Transition trail from draft to pending via SetState
  inputs: {}
  expected:
    exit_code: 0
- name: SetState rejects invalid transitions from draft
  inputs:
    args:
    - trail.SetState("completed")
  expected: {}
- name: SetState rejects transitions from terminal states
  inputs:
    args:
    - trail.SetState("active")
  expected: {}
- name: Create belongs_to link associates crumb with trail
  inputs:
    args:
    - 'link := &Link{LinkType: "belongs_to", FromID: crumb.CrumbID, ToID: trail.TrailID} linksTable.Set("", link) '
  expected:
    exit_code: 0
- name: Multiple crumbs can belong to same trail
  inputs: {}
  expected:
    exit_code: 0
- name: Fetch crumbs on trail via belongs_to filter
  inputs:
    args:
    - 'filter := map[string]any{"link_type": "belongs_to", "to_id": trail.TrailID} linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Delete belongs_to link keeps crumb intact
  inputs: {}
  expected:
    exit_code: 0
- name: Abandon trail deletes associated crumbs
  inputs: {}
  expected: {}
- name: Abandon trail removes belongs_to links
  inputs: {}
  expected: {}
- name: Crumb removed before abandon survives
  inputs: {}
  expected: {}
- name: Complete trail removes belongs_to links
  inputs: {}
  expected: {}
- name: Completed trail crumbs remain accessible
  inputs: {}
  expected: {}
- name: Completed trail crumbs are indistinguishable from permanent crumbs
  description: After completion, crumbs have no belongs_to link and exist as permanent entities.
  inputs: {}
  expected: {}
- name: Trail state is completed after Complete
  inputs: {}
  expected: {}
- name: Trail state is abandoned after Abandon
  inputs: {}
  expected: {}
- name: Complete on non-active trail returns ErrInvalidState
  inputs:
    args:
    - trail.Complete()
  expected: {}
- name: Abandon on non-active trail returns ErrInvalidState
  inputs:
    args:
    - trail.Abandon()
  expected: {}
- name: No orphan links after abandonment
  inputs: {}
  expected: {}
- name: Crumb properties deleted on trail abandonment
  inputs: {}
  expected: {}
- name: Create branches_from link indicates branch point
  inputs:
    args:
    - 'link := &Link{LinkType: "branches_from", FromID: trail.TrailID, ToID: parentCrumb.CrumbID} linksTable.Set("", link) '
  expected:
    exit_code: 0
- name: Query branches_from link to find branch point
  inputs:
    args:
    - 'filter := map[string]any{"link_type": "branches_from", "from_id": trail.TrailID} linksTable.Fetch(filter) '
  expected: {}
- name: Full trail exploration workflow
  description: 'Create a trail branching from a parent crumb, add exploration crumbs, remove one crumb, abandon the trail,
    verify cleanup, then create another trail and complete it successfully. '
  inputs: {}
  expected: {}
- name: Create link generates UUID v7
  description: 'Creating a link with empty ID generates a UUID v7 for LinkID and sets CreatedAt. '
  inputs:
    args:
    - 'link := &Link{LinkType: "belongs_to", FromID: crumb.CrumbID, ToID: trail.TrailID} id, err := linksTable.Set("", link) '
  expected:
    exit_code: 0
- name: Set with existing ID updates link
  description: 'Calling Set with an existing link ID updates the link fields. '
  inputs:
    args:
    - 'link.FromID = crumb2.CrumbID linksTable.Set(linkID, link) '
  expected:
    exit_code: 0
- name: Create belongs_to link for crumb-trail membership
  description: 'A belongs_to link associates a crumb with a trail. FromID is the crumb, ToID is the trail. '
  inputs:
    args:
    - 'link := &Link{LinkType: "belongs_to", FromID: crumb.CrumbID, ToID: trail.TrailID} id, err := linksTable.Set("", link)
      entity, err := linksTable.Get(id) '
  expected:
    exit_code: 0
- name: Create child_of link for crumb hierarchy
  description: 'A child_of link establishes a parent-child hierarchy between crumbs. FromID is the child crumb, ToID is the
    parent crumb. '
  inputs:
    args:
    - 'link := &Link{LinkType: "child_of", FromID: child.CrumbID, ToID: parent.CrumbID} id, err := linksTable.Set("", link)
      entity, err := linksTable.Get(id) '
  expected:
    exit_code: 0
- name: Query children of parent crumb
  description: 'Fetch with LinkType=child_of and ToID=parent returns all child links. '
  inputs:
    args:
    - 'filter := map[string]any{"LinkType": "child_of", "ToID": parent.CrumbID} entities, err := linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Query parent of child crumb
  description: 'Fetch with LinkType=child_of and FromID=child returns the parent link. '
  inputs:
    args:
    - 'filter := map[string]any{"LinkType": "child_of", "FromID": child.CrumbID} entities, err := linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Create branches_from link for trail branch point
  description: 'A branches_from link indicates where a trail branched from a crumb. FromID is the trail, ToID is the branch
    point crumb. '
  inputs:
    args:
    - 'link := &Link{LinkType: "branches_from", FromID: trail.TrailID, ToID: crumb.CrumbID} id, err := linksTable.Set("",
      link) entity, err := linksTable.Get(id) '
  expected:
    exit_code: 0
- name: Query branch point of trail
  description: 'Fetch with LinkType=branches_from and FromID=trail returns the branch point. '
  inputs:
    args:
    - 'filter := map[string]any{"LinkType": "branches_from", "FromID": trail.TrailID} entities, err := linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Create scoped_to link for stash trail scope
  description: 'A scoped_to link scopes a stash to a trail. FromID is the stash, ToID is the trail. '
  inputs:
    args:
    - 'link := &Link{LinkType: "scoped_to", FromID: stash.StashID, ToID: trail.TrailID} id, err := linksTable.Set("", link)
      entity, err := linksTable.Get(id) '
  expected:
    exit_code: 0
- name: Query stashes scoped to trail
  description: 'Fetch with LinkType=scoped_to and ToID=trail returns all scoped stash links. '
  inputs:
    args:
    - 'filter := map[string]any{"LinkType": "scoped_to", "ToID": trail.TrailID} entities, err := linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Query trail scope of stash
  description: 'Fetch with LinkType=scoped_to and FromID=stash returns the trail scope. '
  inputs:
    args:
    - 'filter := map[string]any{"LinkType": "scoped_to", "FromID": stash.StashID} entities, err := linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Fetch by link_type returns only matching links
  description: 'Fetch with LinkType filter returns only links of that type. '
  inputs:
    args:
    - 'filter := map[string]any{"LinkType": "belongs_to"} entities, err := linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Fetch all links without filter
  description: 'Fetch with nil filter returns all links of all types. '
  inputs:
    args:
    - 'entities, err := linksTable.Fetch(nil) '
  expected:
    exit_code: 0
- name: Fetch by from_id returns links from that entity
  description: 'Fetch with FromID filter returns links originating from that entity. '
  inputs:
    args:
    - 'filter := map[string]any{"FromID": crumb.CrumbID} entities, err := linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Fetch by from_id with no matches returns empty
  description: 'Fetch with FromID that has no links returns an empty slice. '
  inputs:
    args:
    - 'filter := map[string]any{"FromID": "nonexistent-id"} entities, err := linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Fetch by to_id returns links to that entity
  description: 'Fetch with ToID filter returns links targeting that entity. '
  inputs:
    args:
    - 'filter := map[string]any{"ToID": trail.TrailID} entities, err := linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Fetch by to_id with no matches returns empty
  description: 'Fetch with ToID that has no links returns an empty slice. '
  inputs:
    args:
    - 'filter := map[string]any{"ToID": "nonexistent-id"} entities, err := linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Fetch with link_type and to_id combined
  description: 'Fetch with both LinkType and ToID filters returns links matching both criteria. '
  inputs:
    args:
    - 'filter := map[string]any{"LinkType": "belongs_to", "ToID": trail.TrailID} entities, err := linksTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Fetch with all three filters
  description: 'Fetch with LinkType, FromID, and ToID filters returns the exact match. '
  inputs:
    args:
    - |
      filter := map[string]any{
        "LinkType": "belongs_to",
        "FromID": crumb.CrumbID,
        "ToID": trail.TrailID,
      }
      entities, err := linksTable.Fetch(filter)
  expected:
    exit_code: 0
- name: Delete link removes it
  description: 'Delete removes a link. Subsequent Get returns ErrNotFound. '
  inputs:
    args:
    - 'err := linksTable.Delete(linkID) _, err = linksTable.Get(linkID) '
  expected: {}
- name: Delete link does not affect other links
  description: 'Deleting one link does not affect other links in the table. '
  inputs:
    args:
    - 'err := linksTable.Delete(link1ID) entity, err := linksTable.Get(link2ID) '
  expected: {}
- name: Delete nonexistent link returns ErrNotFound
  description: 'Delete with a nonexistent ID returns ErrNotFound. '
  inputs:
    args:
    - 'err := linksTable.Delete("nonexistent-uuid-12345") '
  expected: {}
- name: Delete with empty ID returns ErrInvalidID
  description: 'Delete with an empty string ID returns ErrInvalidID. '
  inputs:
    args:
    - 'err := linksTable.Delete("") '
  expected: {}
- name: Get with empty ID returns ErrInvalidID
  description: 'Get with an empty string ID returns ErrInvalidID. '
  inputs:
    args:
    - '_, err := linksTable.Get("") '
  expected: {}
- name: Get nonexistent link returns ErrNotFound
  description: 'Get with a nonexistent ID returns ErrNotFound. '
  inputs:
    args:
    - '_, err := linksTable.Get("nonexistent-uuid-12345") '
  expected: {}
- name: Fetch empty table returns empty slice
  description: 'Fetch on an empty table returns an empty slice, not nil. '
  inputs:
    args:
    - 'entities, err := linksTable.Fetch(nil) '
  expected:
    exit_code: 0
- name: Full link management workflow
  description: 'Creates entities, establishes all four link types, queries via filters, deletes a link, and verifies final
    state. Validates the complete link management lifecycle. '
  inputs: {}
  expected: {}
- name: Create stash generates UUID v7
  inputs:
    args:
    - 'stash := &Stash{Name: "test-stash", StashType: "context", Value: map[string]any{"key": "value"}, Version: 1} id, err
      := stashesTable.Set("", stash) '
  expected:
    exit_code: 0
- name: Set with existing ID updates stash
  inputs:
    args:
    - 'stash.Value = map[string]any{"updated": true} stashesTable.Set(stashID, stash) entity, _ := stashesTable.Get(stashID) '
  expected:
    exit_code: 0
- name: Create resource stash
  inputs:
    args:
    - 'stash := &Stash{Name: "api-connection", StashType: "resource", Value: map[string]any{"uri": "https://api.example.com",
      "kind": "http"}, Version: 1} id, _ := stashesTable.Set("", stash) entity, _ := stashesTable.Get(id) '
  expected:
    exit_code: 0
- name: Create artifact stash
  inputs:
    args:
    - 'stash := &Stash{Name: "build-output", StashType: "artifact", Value: map[string]any{"path": "/tmp/build.zip", "producer":
      "build-agent"}, Version: 1} id, _ := stashesTable.Set("", stash) entity, _ := stashesTable.Get(id) '
  expected:
    exit_code: 0
- name: Create context stash
  inputs:
    args:
    - 'stash := &Stash{Name: "shared-config", StashType: "context", Value: map[string]any{"timeout": 30, "retries": 3}, Version:
      1} id, _ := stashesTable.Set("", stash) entity, _ := stashesTable.Get(id) '
  expected:
    exit_code: 0
- name: Create counter stash
  inputs:
    args:
    - 'stash := &Stash{Name: "request-counter", StashType: "counter", Value: map[string]any{"value": int64(0)}, Version: 1}
      id, _ := stashesTable.Set("", stash) entity, _ := stashesTable.Get(id) '
  expected:
    exit_code: 0
- name: Create lock stash
  inputs:
    args:
    - 'stash := &Stash{Name: "resource-lock", StashType: "lock", Value: nil, Version: 1} id, _ := stashesTable.Set("", stash)
      entity, _ := stashesTable.Get(id) '
  expected:
    exit_code: 0
- name: SetValue updates value and increments version
  inputs:
    args:
    - 'stash.SetValue(map[string]any{"timeout": 60}) stashesTable.Set(stashID, stash) entity, _ := stashesTable.Get(stashID) '
  expected:
    exit_code: 0
- name: SetValue on lock type returns ErrInvalidStashType
  inputs:
    args:
    - 'stash.SetValue(map[string]any{"invalid": true})'
  expected: {}
- name: GetValue returns current value
  inputs:
    args:
    - value := stash.GetValue()
  expected: {}
- name: GetValue returns nil for empty stash
  inputs:
    args:
    - value := stash.GetValue()
  expected: {}
- name: Increment with positive delta
  inputs:
    args:
    - 'newVal, err := stash.Increment(5) stashesTable.Set(stashID, stash) '
  expected:
    exit_code: 0
- name: Increment with negative delta
  inputs:
    args:
    - 'newVal, err := stash.Increment(-3) stashesTable.Set(stashID, stash) '
  expected:
    exit_code: 0
- name: Multiple increments accumulate correctly
  inputs:
    args:
    - 'stash.Increment(10)  // returns 10 stash.Increment(-3)  // returns 7 stash.Increment(5)   // returns 12 stashesTable.Set(stashID,
      stash) '
  expected: {}
- name: Increment on non-counter returns ErrInvalidStashType
  inputs:
    args:
    - stash.Increment(1)
  expected: {}
- name: Acquire lock sets holder and increments version
  inputs:
    args:
    - 'err := stash.Acquire("worker-1") stashesTable.Set(stashID, stash) '
  expected:
    exit_code: 0
- name: Acquire by same holder succeeds (reentrant)
  inputs:
    args:
    - stash.Acquire("worker-1")
  expected:
    exit_code: 0
- name: Acquire by different holder returns ErrLockHeld
  inputs:
    args:
    - stash.Acquire("worker-2")
  expected: {}
- name: Acquire with empty holder returns ErrInvalidHolder
  inputs:
    args:
    - stash.Acquire("")
  expected: {}
- name: Acquire on non-lock returns ErrInvalidStashType
  inputs:
    args:
    - stash.Acquire("worker-1")
  expected: {}
- name: Release lock clears value and increments version
  inputs:
    args:
    - 'versionAfterAcquire := stash.Version err := stash.Release("worker-1") stashesTable.Set(stashID, stash) '
  expected:
    exit_code: 0
- name: Release by wrong holder returns ErrNotLockHolder
  inputs:
    args:
    - stash.Release("worker-2")
  expected: {}
- name: Release on unheld lock returns ErrNotLockHolder
  inputs:
    args:
    - stash.Release("worker-1")
  expected: {}
- name: Release on non-lock returns ErrInvalidStashType
  inputs:
    args:
    - stash.Release("worker-1")
  expected: {}
- name: Version starts at 1 on creation
  inputs:
    args:
    - 'stash := &Stash{Name: "version-test", StashType: "context", Value: map[string]any{}, Version: 1} stashID, _ := stashesTable.Set("",
      stash) entity, _ := stashesTable.Get(stashID) '
  expected: {}
- name: Version increments on each mutation
  inputs:
    args:
    - 'stash.Increment(1) stash.Increment(1) stash.Increment(1) stashesTable.Set(stashID, stash) entity, _ := stashesTable.Get(stashID) '
  expected: {}
- name: Fetch by stash_type returns only matching stashes
  inputs:
    args:
    - 'filter := map[string]any{"StashType": "counter"} entities, _ := stashesTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Fetch by name returns matching stash
  inputs:
    args:
    - 'filter := map[string]any{"Name": "shared-config"} entities, _ := stashesTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Fetch with no filter returns all stashes
  inputs:
    args:
    - entities, _ := stashesTable.Fetch(nil)
  expected:
    exit_code: 0
- name: Fetch with no matches returns empty slice
  inputs:
    args:
    - 'filter := map[string]any{"StashType": "nonexistent"} entities, _ := stashesTable.Fetch(filter) '
  expected:
    exit_code: 0
- name: Delete stash removes it
  inputs:
    args:
    - 'err := stashesTable.Delete(stashID) _, getErr := stashesTable.Get(stashID) '
  expected: {}
- name: Delete nonexistent stash returns ErrNotFound
  inputs:
    args:
    - stashesTable.Delete("nonexistent-uuid-12345")
  expected: {}
- name: Delete with empty ID returns ErrInvalidID
  inputs:
    args:
    - stashesTable.Delete("")
  expected: {}
- name: Get with empty ID returns ErrInvalidID
  inputs:
    args:
    - stashesTable.Get("")
  expected: {}
- name: Get nonexistent stash returns ErrNotFound
  inputs:
    args:
    - stashesTable.Get("nonexistent-uuid-12345")
  expected: {}
- name: Fetch on empty table returns empty slice
  inputs:
    args:
    - entities, _ := stashesTable.Fetch(nil)
  expected:
    exit_code: 0
- name: History entry created for each mutation
  description: Verify that stash history is recorded for each operation
  inputs:
    args:
    - 'stashesTable := backend.GetTable("stashes").(*sqlite.Table) history, err := stashesTable.FetchStashHistory(stashID) '
  expected:
    exit_code: 0
- name: History entries queryable by stash ID
  description: Verify FetchStashHistory returns entries ordered by version
  inputs:
    args:
    - 'stashesTable := backend.GetTable("stashes").(*sqlite.Table) history, err := stashesTable.FetchStashHistory(stashID) '
  expected:
    exit_code: 0
- name: History records operation details
  description: Verify history entries contain version, value, operation, and timestamps
  inputs:
    args:
    - 'stashesTable := backend.GetTable("stashes").(*sqlite.Table) history, err := stashesTable.FetchStashHistory(stashID) '
  expected:
    exit_code: 0
- name: Full stash operations workflow
  description: 'Create stashes of each type, exercise type-specific operations, verify version tracking, filter queries, and
    cleanup. '
  inputs: {}
  expected: {}
- name: Create belongs_to link associates crumb with trail
  inputs:
    args:
    - 'link := &Link{LinkType: "belongs_to", FromID: crumb.CrumbID, ToID: trail.TrailID} linksTable.Set("", link) '
  expected:
    exit_code: 0
- name: Crumb without belongs_to link is orphaned or permanent
  description: A crumb with no belongs_to link is either permanent (was on completed trail) or orphaned
  inputs:
    args:
    - 'linksTable.Fetch(map[string]any{"link_type": "belongs_to", "from_id": crumb.CrumbID}) '
  expected: {}
- name: Crumb can belong to only one trail
  description: Attempting to add second belongs_to link for same crumb fails due to uniqueness constraint
  inputs:
    args:
    - 'link := &Link{LinkType: "belongs_to", FromID: crumb.CrumbID, ToID: trail2.TrailID} linksTable.Set("", link) '
  expected: {}
- name: Moving crumb requires deleting old link first
  inputs:
    args:
    - 'linksTable.Fetch(map[string]any{"link_type": "belongs_to", "from_id": crumb.CrumbID}) '
  expected:
    exit_code: 0
- name: Fetch all crumbs belonging to a trail
  inputs:
    args:
    - 'linksTable.Fetch(map[string]any{"link_type": "belongs_to", "to_id": trail.TrailID}) '
  expected: {}
- name: Fetch returns empty for trail with no crumbs
  inputs:
    args:
    - 'linksTable.Fetch(map[string]any{"link_type": "belongs_to", "to_id": trail.TrailID}) '
  expected: {}
- name: Fetch crumbs across multiple trails
  inputs: {}
  expected: {}
- name: Move crumb from one trail to another
  inputs: {}
  expected:
    exit_code: 0
- name: Crumb data unchanged after moving trails
  inputs: {}
  expected: {}
- name: Complete trail removes all belongs_to links
  inputs: {}
  expected: {}
- name: Complete sets CompletedAt timestamp
  inputs: {}
  expected: {}
- name: Crumbs exist after trail completion
  inputs: {}
  expected: {}
- name: Completed crumbs have no belongs_to link
  inputs: {}
  expected: {}
- name: Permanent crumbs indistinguishable from never-trailed crumbs
  description: After completion, crumbs look the same as crumbs that were never on a trail
  inputs: {}
  expected: {}
- name: Abandon trail deletes associated crumbs
  inputs: {}
  expected: {}
- name: Abandon only deletes crumbs with belongs_to link
  description: Crumbs not linked to the trail are unaffected
  inputs: {}
  expected: {}
- name: Crumb removed from trail before abandon survives
  inputs: {}
  expected: {}
- name: Abandon deletes crumb properties
  inputs: {}
  expected: {}
- name: Abandon deletes crumb metadata
  inputs: {}
  expected: {}
- name: Abandon deletes all links involving crumb
  description: Both belongs_to and any child_of links are removed
  inputs: {}
  expected: {}
- name: Abandon removes belongs_to links for trail
  inputs: {}
  expected: {}
- name: Abandoned trail still retrievable
  inputs: {}
  expected: {}
- name: Abandoned trail has no associated crumbs
  inputs: {}
  expected: {}
- name: Complete requires active state
  inputs:
    args:
    - trail.Complete()
  expected: {}
- name: Complete on pending state returns error
  inputs:
    args:
    - trail.Complete()
  expected: {}
- name: Complete on completed state returns error
  inputs:
    args:
    - trail.Complete()
  expected: {}
- name: Abandon requires active state
  inputs:
    args:
    - trail.Abandon()
  expected: {}
- name: Abandon on completed state returns error
  inputs:
    args:
    - trail.Abandon()
  expected: {}
- name: Abandon on abandoned state returns error
  inputs:
    args:
    - trail.Abandon()
  expected: {}
- name: Complete lifecycle - trail as container with completion
  description: Create trail, add crumbs, complete, verify crumbs become permanent
  inputs: {}
  expected: {}
- name: Abandon lifecycle - trail as container with cleanup
  description: Create trail, add crumbs with properties, abandon, verify cascade deletion
  inputs: {}
  expected: {}

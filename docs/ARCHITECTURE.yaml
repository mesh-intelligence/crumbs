id: crumbs
title: Crumbs Architecture

overview:
  summary: |
    Crumbs is a storage system for work items with first-class support for exploratory trails. The
    core insight is that coding agents need backtracking: an agent drops crumbs as it explores an
    implementation approach, and if the approach leads nowhere, the agent abandons the entire trail
    without polluting the permanent task list.

    We use an ORM-style pattern for data access. Applications call Cupboard.GetTable(name) to get a
    table accessor, then use uniform CRUD operations (Get, Set, Delete, Fetch) that work with entity
    objects (Crumb, Trail, Property, etc.). Entity methods modify structs in memory; callers persist
    changes by calling Table.Set. This separates storage mechanics from domain logic and keeps the
    interface consistent across all entity types.

    The system provides a Go library (pkg/api, pkg/schema) for agents and a command-line tool
    (cmd/cupboard) for development and personal use. All operations use UUID v7 identifiers
    (time-ordered, sortable).

  lifecycle: |
    Crumb states (prd003-crumbs-interface R2): draft → pending → ready → taken → pebble or dust.
    Terminal states are pebble (completed successfully) and dust (failed or abandoned). Named
    transition methods exist only for semantically distinct endpoints: Pebble() and Dust() for
    crumbs; other transitions use SetState.

    Trail states: draft → pending → active → completed or abandoned. Crumbs can only be added to a
    trail in active state. Trail.Complete() and Trail.Abandon() update the trail's state field. When
    persisted via Table.Set, the backend performs cascade operations: completing a trail transitions
    its crumbs to pebble (links retained as history), abandoning transitions crumbs to dust (links
    also retained).

    Stash states: draft → active → archived. A trail cannot transition to active unless all its
    stashes are in active state. When a trail completes or is abandoned, its stashes transition to
    archived.

    Link types and their semantics: child_of (crumb → crumb) — child blocked until parent reaches
    pebble; branches_from (trail → crumb) — branching trail cannot go active until branch point
    crumb reaches pebble; belongs_to (crumb → trail) — crumb follows trail lifecycle, links
    retained permanently in both complete and abandon cases; scoped_to (stash → trail) — stash
    shares trail lifecycle.

    Trail ownership rule: All crumbs must belong to a trail. Links are never deleted. A crumb
    without a belongs_to link is orphaned and should be cleaned up.

  coordination_pattern: |
    Crumbs provides storage, not coordination. Agents or coordination frameworks build claiming,
    timeouts, and announcements on top of the Cupboard API. We expose synchronous read/write
    operations; agents add workflow semantics.

interfaces:
  data_structures:
    - name: Config
      description: Backend selection and configuration. Backend field selects the backend type; DataDir specifies the data directory for the SQLite backend. See prd001-cupboard-core R1.
    - name: SQLiteConfig
      description: SQLite-specific configuration for sync strategy, batch size, and batch interval. See prd002-sqlite-backend R16.
    - name: Crumb
      description: Work item entity with CrumbID, Name, State, CreatedAt, UpdatedAt, Properties. Methods update struct fields only. See prd003-crumbs-interface.
    - name: Trail
      description: Exploration session entity with TrailID, State, CreatedAt, CompletedAt. Complete() and Abandon() update state in memory. See prd006-trails-interface.
    - name: Property
      description: Property definition entity with PropertyID, Name, Description, ValueType, CreatedAt. See prd004-properties-interface.
    - name: Category
      description: Categorical value for a property with CategoryID, PropertyID, Name, Ordinal. See prd004-properties-interface.
    - name: Stash
      description: Shared state entity with StashID, Name, StashType, Value, Version, CreatedAt. See prd008-stash-interface.
    - name: Metadata
      description: Supplementary data with MetadataID, CrumbID, TableName, Content, PropertyID, CreatedAt. See prd005-metadata-interface.
    - name: Link
      description: Typed directed edge with LinkID, LinkType, FromID, ToID, CreatedAt. Link types are belongs_to, child_of, branches_from, scoped_to. See prd007-links-interface.

  operations:
    - name: Cupboard interface
      description: "GetTable(name string) (Table, error), Attach(config Config) error, Detach() error. See prd001-cupboard-core R2."
    - name: Table interface
      description: "Get(id string) (any, error), Set(id string, data any) (string, error), Delete(id string) error, Fetch(filter map[string]any) ([]any, error). See prd001-cupboard-core R3."

  announcements: []

components:
  - name: Interfaces (pkg/api)
    responsibility: Contract package. Contains the Cupboard interface, Table interface, Config, and SQLiteConfig. Callers import only this package to use the library. Changes here require changes in every implementation; changes to implementations never touch this package.
    capabilities:
      - Defines Cupboard interface (GetTable, Attach, Detach)
      - Defines Table interface (Get, Set, Delete, Fetch)
      - Defines Config and SQLiteConfig structs with Validate methods
    references: prd001-cupboard-core R2, R3

  - name: Entity Types (pkg/schema)
    responsibility: In-memory domain logic. Structs (Crumb, Trail, Property, Category, Stash, Metadata, Link) and their methods (SetState, Pebble, Dust, Complete, Abandon, etc.). Methods update struct fields only — no I/O, no database knowledge. No dependency on pkg/api or internal/.
    capabilities:
      - Crumb struct with state transition methods (Pebble, Dust, SetState)
      - Trail struct with lifecycle methods (Complete, Abandon)
      - Stash struct with value methods (SetValue, Increment, Acquire, Release)
      - Property, Category, Metadata, Link, Schema structs
    references: prd003-crumbs-interface, prd006-trails-interface, prd008-stash-interface, prd004-properties-interface, prd005-metadata-interface, prd007-links-interface

  - name: Constants (pkg/constants)
    responsibility: Single source of truth for all domain strings. State values, link types, property defaults, sync strategies, and table names are defined here as named constants. No package in the codebase uses raw string literals for these values.
    capabilities:
      - Crumb states (draft, pending, ready, taken, pebble, dust)
      - Trail states (draft, pending, active, completed, abandoned)
      - Link types (belongs_to, child_of, branches_from, scoped_to)
      - Table names and sync strategy names
    references: Decision DD13

  - name: SQLite Engine (internal/persistence/engine)
    responsibility: SQLite lifecycle and JSONL file I/O. Opens and closes the database, creates the schema, manages the sync.RWMutex, and implements the atomic JSONL write pattern (temp file, fsync, rename). Knows nothing about entity types.
    capabilities:
      - Schema creation (9 tables, 12 indexes)
      - JSONL read/write with atomic rename
      - Sync strategy implementations (immediate, on_close, batch)
    references: prd002-sqlite-backend R3, R4, R14, R16

  - name: SQL Mapping (internal/persistence/mapping)
    responsibility: Entity-to-SQL row translation. One mapper per entity type converts between Go structs and SQL column values. This package is the only place that knows both entity field names and SQL column names. Adding a column means changing a mapper, not the engine or the interface.
    capabilities:
      - Hydration (SQL row to entity struct) for all entity types
      - Dehydration (entity struct to SQL params) for all entity types
    references: prd002-sqlite-backend R5, R6, R7, R8, R9, R10, R11, R12, R13

  - name: CLI (cmd/cupboard)
    responsibility: Command-line tool for development and personal use. Commands map to Cupboard operations. Config file selects backend. Supports generic table commands and issue-tracking commands.
    capabilities:
      - Generic table commands for all standard table names (get, set, list, delete)
      - Issue-tracking commands (ready, create, show, update, close, comments add)
      - JSON output flag for scripting
      - Platform-specific configuration directory resolution
    references: prd009-cupboard-cli, prd010-configuration-directories

design_decisions:
  - id: DD1
    title: UUID v7 for all identifiers
    decision: We use UUID v7 (time-ordered UUIDs per RFC 9562) for all entity identifiers.
    benefits:
      - Sortable by creation time without separate timestamp columns
      - Simplifies pagination and reduces index size
      - Works across distributed backends
    alternatives_rejected:
      - Auto-increment IDs are not suitable for distributed systems
      - UUID v4 lacks time ordering

  - id: DD2
    title: Properties as first-class entities
    decision: Property definitions have their own IDs and table. Type-specific handling (categorical, text, integer, list) enforces value types.
    benefits:
      - Runtime extensibility — agents define new properties without schema migrations
      - Efficient queries on typed values
    alternatives_rejected:
      - Storing properties as JSON blobs is less queryable and loses type safety

  - id: DD3
    title: Trails with complete/abandon semantics
    decision: Trails represent agent exploration sessions. Complete transitions crumbs to pebble; Abandon transitions crumbs to dust. Links are retained in both cases.
    benefits:
      - Keeps the permanent task list clean
      - Makes agent exploration explicit — try an approach, abandon if it fails, complete if it succeeds
    alternatives_rejected:
      - Marking crumbs as "tentative" requires agents to manually track and clean up failed explorations

  - id: DD4
    title: Pluggable backends with full interface
    decision: Each backend implements the entire Cupboard interface.
    benefits:
      - Backend-specific optimizations without leaking details into the API
    alternatives_rejected:
      - A generic SQL backend with schema generation is less flexible and cannot leverage backend-specific features

  - id: DD5
    title: Synchronous API
    decision: Operations are synchronous.
    benefits:
      - Simplicity — no async complexity before we need it
    alternatives_rejected:
      - Async adds complexity before we need it

  - id: DD6
    title: JSONL as source of truth for SQLite backend
    decision: The SQLite backend uses JSONL files (one JSON object per line) as the canonical data store. SQLite (modernc.org/sqlite, pure Go) serves as a query engine. On startup we load JSONL into SQLite; on writes we persist back to JSONL. Sync strategy is configurable (immediate, on_close, batch).
    benefits:
      - Human-readable files and easy backup
      - Atomic write pattern (temp file, fsync, rename) prevents partial writes
      - Code reuse via SQL for filtering, joins, and indexing
    alternatives_rejected:
      - Raw JSON with custom query logic duplicates work SQL handles well
      - Pure SQLite loses the human-readable file benefit

  - id: DD7
    title: Properties always present with type-based defaults
    decision: Every crumb has a value for every defined property. When a property is defined, existing crumbs are backfilled. When a crumb is created, all properties are initialized.
    benefits:
      - Eliminates null-checking complexity
      - Ensures consistent schema across all crumbs
    alternatives_rejected:
      - Allowing "not set" properties requires null handling everywhere and makes queries more complex

  - id: DD8
    title: Stashes as separate entities for shared state
    decision: When multiple crumbs on a trail need to share state, we use stashes — not "special crumbs" or property values. Stashes are versioned with full history.
    benefits:
      - Supports auditability and debugging
      - Trail-scoped lifecycle keeps stash cleanup automatic
    alternatives_rejected:
      - Encoding shared state in crumb properties conflates task attributes with coordination state
      - Using external storage loses the trail-scoped lifecycle

  - id: DD9
    title: ORM-style pattern with uniform Table interface
    decision: A single Table interface (Get, Set, Delete, Fetch) for all entity types. Cupboard.GetTable(name) returns the same Table interface regardless of entity type. Entity methods modify structs in memory; callers persist via Table.Set.
    benefits:
      - Consistent API across all entities
      - Simpler backend implementation (one interface to implement per table)
      - Clear separation between storage operations and domain logic
    alternatives_rejected:
      - Entity-specific interfaces (CrumbTable, TrailTable, etc.) create a larger API surface, duplicate CRUD patterns, and mix storage concerns with domain logic

  - id: DD10
    title: Links table for all relationships
    decision: All entity relationships use the links table with typed edges (belongs_to, child_of, branches_from, scoped_to).
    benefits:
      - One consistent pattern for all relationships
      - Enables graph queries and traversal
    alternatives_rejected:
      - Direct fields (e.g., Trail.ParentCrumbID) create inconsistency and require different query patterns

  - id: DD11
    title: OpenTelemetry for observability, not plain logs
    decision: We use OpenTelemetry (traces, metrics, logs) as the observability layer. We do not use plain structured logging for application telemetry.
    benefits:
      - Correlated traces and spans across operations
      - Metrics and structured log records flow through the same pipeline
    alternatives_rejected:
      - Plain slog logging loses trace correlation, cannot produce metrics, and requires a separate system for distributed tracing

  - id: DD12
    title: Package separation of interfaces, domain types, and constants
    decision: We split the public API surface into three packages. pkg/api holds only interfaces and config. pkg/schema holds entity structs and state-transition methods. pkg/constants holds all domain strings as named constants.
    benefits:
      - Each package has a single reason to change
      - An AI coding agent working on the persistence layer never needs to read entity methods
      - An agent working on domain rules never needs to read SQL
    alternatives_rejected:
      - A single pkg/types package conflates three different rates of change and forces larger context windows for AI agents

  - id: DD13
    title: Centralizing domain strings as named constants
    decision: All state values, link types, table names, sync strategies, and property defaults are defined in pkg/constants as named Go constants. No package uses raw string literals for these values.
    benefits:
      - Prevents the "magic string" problem — a rename requires a change in one place
      - AI coding agents are particularly susceptible to magic-string errors
    alternatives_rejected:
      - Defining constants in the package that owns the concept scatters the lookup across multiple files

technology_choices:
  - technology: Go
    reason: CLI tool and library; strong concurrency, static typing.
  - technology: UUID v7 (RFC 9562)
    reason: Time-ordered, sortable, distributed-safe IDs.
  - technology: cobra + viper
    reason: Command parsing and config management for the CLI.
  - technology: modernc.org/sqlite
    reason: Pure Go SQLite driver; JSONL files as source of truth, SQLite as query engine.
  - technology: Go testing + testify
    reason: Unit and integration tests across all layers.
  - technology: OpenTelemetry (go.opentelemetry.io/otel)
    reason: Traces, metrics, and structured logs in a single pipeline.

project_structure:
  - path: cmd/cupboard/
    role: CLI entrypoint
  - path: pkg/api/
    role: Intent — Cupboard, Table interfaces and Config
  - path: pkg/schema/
    role: Domain — entity structs and state-transition methods
  - path: pkg/constants/
    role: Rules — states, link types, property defaults (no magic strings)
  - path: internal/persistence/engine/
    role: Infrastructure — SQLite lifecycle, JSONL flush, file I/O
  - path: internal/persistence/mapping/
    role: Translation — entity struct to/from SQL row (hydration/dehydration)
  - path: internal/telemetry/
    role: Observability — OpenTelemetry implementation
  - path: go.mod
    role: Module definition

implementation_status:
  note: Release 01.0 (core storage with SQLite backend) is in progress. See road-map.yaml for the full release schedule, use case status, and prioritization rules. Success criteria from VISION.yaml — operations complete with low latency, agents integrate the library quickly, trail workflows feel natural for coding agents exploring implementation approaches.

related_documents:
  - id: VISION.yaml
    path: VISION.yaml
    note: What we are building and why; success criteria and boundaries
  - id: road-map.yaml
    path: road-map.yaml
    note: Release schedule, use cases, prioritization rules
  - id: prd001-cupboard-core.yaml
    path: specs/product-requirements/prd001-cupboard-core.yaml
    note: Cupboard interface, configuration, lifecycle
  - id: prd002-sqlite-backend.yaml
    path: specs/product-requirements/prd002-sqlite-backend.yaml
    note: SQLite backend internals, JSON-to-SQLite sync, graph model
  - id: prd003-crumbs-interface.yaml
    path: specs/product-requirements/prd003-crumbs-interface.yaml
    note: Crumb entity, state transitions, property methods
  - id: prd006-trails-interface.yaml
    path: specs/product-requirements/prd006-trails-interface.yaml
    note: Trail entity, lifecycle methods, crumb membership
  - id: prd004-properties-interface.yaml
    path: specs/product-requirements/prd004-properties-interface.yaml
    note: Property and Category entities, value types
  - id: prd005-metadata-interface.yaml
    path: specs/product-requirements/prd005-metadata-interface.yaml
    note: Metadata entity, schema registration
  - id: prd008-stash-interface.yaml
    path: specs/product-requirements/prd008-stash-interface.yaml
    note: Stash entity, shared state, versioning
  - id: eng01-git-integration.yaml
    path: engineering/eng01-git-integration.yaml
    note: Git conventions — JSONL in git, task branches, trails vs git branches, merge behavior
  - id: eng02-generation-workflow.yaml
    path: engineering/eng02-generation-workflow.yaml
    note: Generation lifecycle — open, generate, close; task branch naming; scripts
  - id: eng05-testing-strategy.yaml
    path: engineering/eng05-testing-strategy.yaml
    note: Layered testing — unit (pkg/schema), integration (internal/persistence), e2e (cmd/cupboard)
